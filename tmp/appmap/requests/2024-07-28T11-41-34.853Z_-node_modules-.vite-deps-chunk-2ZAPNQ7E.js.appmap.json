{
  "events": [
    {
      "event": "call",
      "http_server_request": {
        "path_info": "/node_modules/.vite/deps/chunk-2ZAPNQ7E.js",
        "request_method": "GET",
        "headers": {
          "Host": "localhost:3000",
          "Connection": "keep-alive",
          "Sec-Ch-Ua": "\"Not/A)Brand\";v=\"8\", \"Chromium\";v=\"126\", \"Google Chrome\";v=\"126\"",
          "Origin": "http://localhost:3000",
          "Sec-Ch-Ua-Mobile": "?0",
          "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
          "Sec-Ch-Ua-Platform": "\"macOS\"",
          "Accept": "*/*",
          "Sec-Fetch-Site": "same-origin",
          "Sec-Fetch-Mode": "cors",
          "Sec-Fetch-Dest": "script",
          "Referer": "http://localhost:3000/node_modules/.vite/deps/react-syntax-highlighter.js?v=69cd69d1",
          "Accept-Encoding": "gzip, deflate, br, zstd",
          "Accept-Language": "en-US,en;q=0.9",
          "Cookie": "__stripe_mid=ebfd26b6-c829-4742-8893-abaf894eb93edc4c96; colorMode=%22dark%22"
        },
        "protocol": "HTTP/1.1"
      },
      "id": 1,
      "thread_id": 0,
      "message": [
        {
          "name": "v",
          "value": "'b39bb78e'",
          "class": "String"
        }
      ]
    },
    {
      "event": "return",
      "http_server_response": {
        "status_code": 200,
        "headers": {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "text/javascript",
          "Cache-Control": "max-age=31536000,immutable",
          "Etag": "W/\"4026-FQ+PkyET1A1XIohCI/KBR9Phfng\""
        },
        "return_value": {
          "class": "[ResponseBody]",
          "value": "import {\n  __commonJS\n} from \"/node_modules/.vite/deps/chunk-4B2QHNJT.js?v=b39bb78e\";\n\n// node_modules/refractor/lang/csharp.js\nvar require_csharp = __commonJS({\n  \"node_modules/refractor/lang/csharp.js\"(exports, module) {\n    module.exports = csharp;\n    csharp.displayName = \"csharp\";\n    csharp.aliases = [\"dotnet\", \"cs\"];\n    function csharp(Prism) {\n      ;\n      (function(Prism2) {\n        function replace(pattern, replacements) {\n          return pattern.replace(/<<(\\d+)>>/g, function(m, index) {\n            return \"(?:\" + replacements[+index] + \")\";\n          });\n        }\n        function re(pattern, replacements, flags) {\n          return RegExp(replace(pattern, replacements), flags || \"\");\n        }\n        function nested(pattern, depthLog2) {\n          for (var i = 0; i < depthLog2; i++) {\n            pattern = pattern.replace(/<<self>>/g, function() {\n              return \"(?:\" + pattern + \")\";\n            });\n          }\n          return pattern.replace(/<<self>>/g, \"[^\\\\s\\\\S]\");\n        }\n        var keywordKinds = {\n          // keywords which represent a return or variable type\n          type: \"bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void\",\n          // keywords which are used to declare a type\n          typeDeclaration: \"class enum interface record struct\",\n          // contextual keywords\n          // (\"var\" and \"dynamic\" are missing because they are used like types)\n          contextual: \"add alias and ascending async await by descending from(?=\\\\s*(?:\\\\w|$)) get global group into init(?=\\\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\\\s*{)\",\n          // all other keywords\n          other: \"abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield\"\n        };\n        function keywordsToPattern(words) {\n          return \"\\\\b(?:\" + words.trim().replace(/ /g, \"|\") + \")\\\\b\";\n        }\n        var typeDeclarationKeywords = keywordsToPattern(\n          keywordKinds.typeDeclaration\n        );\n        var keywords = RegExp(\n          keywordsToPattern(\n            keywordKinds.type + \" \" + keywordKinds.typeDeclaration + \" \" + keywordKinds.contextual + \" \" + keywordKinds.other\n          )\n        );\n        var nonTypeKeywords = keywordsToPattern(\n          keywordKinds.typeDeclaration + \" \" + keywordKinds.contextual + \" \" + keywordKinds.other\n        );\n        var nonContextualKeywords = keywordsToPattern(\n          keywordKinds.type + \" \" + keywordKinds.typeDeclaration + \" \" + keywordKinds.other\n        );\n        var generic = nested(/<(?:[^<>;=+\\-*/%&|^]|<<self>>)*>/.source, 2);\n        var nestedRound = nested(/\\((?:[^()]|<<self>>)*\\)/.source, 2);\n        var name = /@?\\b[A-Za-z_]\\w*\\b/.source;\n        var genericName = replace(/<<0>>(?:\\s*<<1>>)?/.source, [name, generic]);\n        var identifier = replace(/(?!<<0>>)<<1>>(?:\\s*\\.\\s*<<1>>)*/.source, [\n          nonTypeKeywords,\n          genericName\n        ]);\n        var array = /\\[\\s*(?:,\\s*)*\\]/.source;\n        var typeExpressionWithoutTuple = replace(\n          /<<0>>(?:\\s*(?:\\?\\s*)?<<1>>)*(?:\\s*\\?)?/.source,\n          [identifier, array]\n        );\n        var tupleElement = replace(\n          /[^,()<>[\\];=+\\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source,\n          [generic, nestedRound, array]\n        );\n        var tuple = replace(/\\(<<0>>+(?:,<<0>>+)+\\)/.source, [tupleElement]);\n        var typeExpression = replace(\n          /(?:<<0>>|<<1>>)(?:\\s*(?:\\?\\s*)?<<2>>)*(?:\\s*\\?)?/.source,\n          [tuple, identifier, array]\n        );\n        var typeInside = {\n          keyword: keywords,\n          punctuation: /[<>()?,.:[\\]]/\n        };\n        var character = /'(?:[^\\r\\n'\\\\]|\\\\.|\\\\[Uux][\\da-fA-F]{1,8})'/.source;\n        var regularString = /\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/.source;\n        var verbatimString = /@\"(?:\"\"|\\\\[\\s\\S]|[^\\\\\"])*\"(?!\")/.source;\n        Prism2.languages.csharp = Prism2.languages.extend(\"clike\", {\n          string: [\n            {\n              pattern: re(/(^|[^$\\\\])<<0>>/.source, [verbatimString]),\n              lookbehind: true,\n              greedy: true\n            },\n            {\n              pattern: re(/(^|[^@$\\\\])<<0>>/.source, [regularString]),\n              lookbehind: true,\n              greedy: true\n            }\n          ],\n          \"class-name\": [\n            {\n              // Using static\n              // using static System.Math;\n              pattern: re(/(\\busing\\s+static\\s+)<<0>>(?=\\s*;)/.source, [\n                identifier\n              ]),\n              lookbehind: true,\n              inside: typeInside\n            },\n            {\n              // Using alias (type)\n              // using Project = PC.MyCompany.Project;\n              pattern: re(/(\\busing\\s+<<0>>\\s*=\\s*)<<1>>(?=\\s*;)/.source, [\n                name,\n                typeExpression\n              ]),\n              lookbehind: true,\n              inside: typeInside\n            },\n            {\n              // Using alias (alias)\n              // using Project = PC.MyCompany.Project;\n              pattern: re(/(\\busing\\s+)<<0>>(?=\\s*=)/.source, [name]),\n              lookbehind: true\n            },\n            {\n              // Type declarations\n              // class Foo<A, B>\n              // interface Foo<out A, B>\n              pattern: re(/(\\b<<0>>\\s+)<<1>>/.source, [\n                typeDeclarationKeywords,\n                genericName\n              ]),\n              lookbehind: true,\n              inside: typeInside\n            },\n            {\n              // Single catch exception declaration\n              // catch(Foo)\n              // (things like catch(Foo e) is covered by variable declaration)\n              pattern: re(/(\\bcatch\\s*\\(\\s*)<<0>>/.source, [identifier]),\n              lookbehind: true,\n              inside: typeInside\n            },\n            {\n              // Name of the type parameter of generic constraints\n              // where Foo : class\n              pattern: re(/(\\bwhere\\s+)<<0>>/.source, [name]),\n              lookbehind: true\n            },\n            {\n              // Casts and checks via as and is.\n              // as Foo<A>, is Bar<B>\n              // (things like if(a is Foo b) is covered by variable declaration)\n              pattern: re(/(\\b(?:is(?:\\s+not)?|as)\\s+)<<0>>/.source, [\n                typeExpressionWithoutTuple\n              ]),\n              lookbehind: true,\n              inside: typeInside\n            },\n            {\n              // Variable, field and parameter declaration\n              // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)\n              pattern: re(\n                /\\b<<0>>(?=\\s+(?!<<1>>|with\\s*\\{)<<2>>(?:\\s*[=,;:{)\\]]|\\s+(?:in|when)\\b))/.source,\n                [typeExpression, nonContextualKeywords, name]\n              ),\n              inside: typeInside\n            }\n          ],\n          keyword: keywords,\n          // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals\n          number: /(?:\\b0(?:x[\\da-f_]*[\\da-f]|b[01_]*[01])|(?:\\B\\.\\d+(?:_+\\d+)*|\\b\\d+(?:_+\\d+)*(?:\\.\\d+(?:_+\\d+)*)?)(?:e[-+]?\\d+(?:_+\\d+)*)?)(?:[dflmu]|lu|ul)?\\b/i,\n          operator: />>=?|<<=?|[-=]>|([-+&|])\\1|~|\\?\\?=?|[-+*/%&|^!=<>]=?/,\n          punctuation: /\\?\\.?|::|[{}[\\];(),.:]/\n        });\n        Prism2.languages.insertBefore(\"csharp\", \"number\", {\n          range: {\n            pattern: /\\.\\./,\n            alias: \"operator\"\n          }\n        });\n        Prism2.languages.insertBefore(\"csharp\", \"punctuation\", {\n          \"named-parameter\": {\n            pattern: re(/([(,]\\s*)<<0>>(?=\\s*:)/.source, [name]),\n            lookbehind: true,\n            alias: \"punctuation\"\n          }\n        });\n        Prism2.languages.insertBefore(\"csharp\", \"class-name\", {\n          namespace: {\n            // namespace Foo.Bar {}\n            // using Foo.Bar;\n            pattern: re(\n              /(\\b(?:namespace|using)\\s+)<<0>>(?:\\s*\\.\\s*<<0>>)*(?=\\s*[;{])/.source,\n              [name]\n            ),\n            lookbehind: true,\n            inside: {\n              punctuation: /\\./\n            }\n          },\n          \"type-expression\": {\n            // default(Foo), typeof(Foo<Bar>), sizeof(int)\n            pattern: re(\n              /(\\b(?:default|sizeof|typeof)\\s*\\(\\s*(?!\\s))(?:[^()\\s]|\\s(?!\\s)|<<0>>)*(?=\\s*\\))/.source,\n              [nestedRound]\n            ),\n            lookbehind: true,\n            alias: \"class-name\",\n            inside: typeInside\n          },\n          \"return-type\": {\n            // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0\n            // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];\n            // int Foo => 0; int Foo { get; set } = 0;\n            pattern: re(\n              /<<0>>(?=\\s+(?:<<1>>\\s*(?:=>|[({]|\\.\\s*this\\s*\\[)|this\\s*\\[))/.source,\n              [typeExpression, identifier]\n            ),\n            inside: typeInside,\n            alias: \"class-name\"\n          },\n          \"constructor-invocation\": {\n            // new List<Foo<Bar[]>> { }\n            pattern: re(/(\\bnew\\s+)<<0>>(?=\\s*[[({])/.source, [typeExpression]),\n            lookbehind: true,\n            inside: typeInside,\n            alias: \"class-name\"\n          },\n          /*'explicit-implementation': {\n          // int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();\n          pattern: replace(/\\b<<0>>(?=\\.<<1>>)/, className, methodOrPropertyDeclaration),\n          inside: classNameInside,\n          alias: 'class-name'\n          },*/\n          \"generic-method\": {\n            // foo<Bar>()\n            pattern: re(/<<0>>\\s*<<1>>(?=\\s*\\()/.source, [name, generic]),\n  ... (6422 more characters)"
        }
      },
      "id": 2,
      "thread_id": 0,
      "parent_id": 1,
      "elapsed": 0.0006068749353289604
    }
  ],
  "version": "1.12",
  "metadata": {
    "client": {
      "name": "appmap-node",
      "version": "2.23.1",
      "url": "https://github.com/getappmap/appmap-node"
    },
    "language": {
      "name": "javascript",
      "engine": "Node.js",
      "version": "v20.15.1"
    },
    "app": "MyApp",
    "recorder": {
      "type": "requests",
      "name": "requests"
    },
    "name": "GET /node_modules/.vite/deps/chunk-2ZAPNQ7E.js (200) â€” 2024-07-28T11:41:34.853Z"
  },
  "classMap": [
    {
      "type": "http",
      "name": "HTTP server requests",
      "children": [
        {
          "type": "route",
          "name": "GET /node_modules/.vite/deps/chunk-2ZAPNQ7E.js"
        }
      ]
    }
  ]
}