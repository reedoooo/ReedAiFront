{
  "events": [
    {
      "event": "call",
      "http_server_request": {
        "path_info": "/node_modules/.vite/deps/chunk-U5KJ3HQ7.js",
        "request_method": "GET",
        "headers": {
          "Host": "localhost:3000",
          "Connection": "keep-alive",
          "Sec-Ch-Ua": "\"Not/A)Brand\";v=\"8\", \"Chromium\";v=\"126\", \"Google Chrome\";v=\"126\"",
          "Origin": "http://localhost:3000",
          "Sec-Ch-Ua-Mobile": "?0",
          "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
          "Sec-Ch-Ua-Platform": "\"macOS\"",
          "Accept": "*/*",
          "Sec-Fetch-Site": "same-origin",
          "Sec-Fetch-Mode": "cors",
          "Sec-Fetch-Dest": "script",
          "Referer": "http://localhost:3000/node_modules/.vite/deps/react-syntax-highlighter.js?v=69cd69d1",
          "Accept-Encoding": "gzip, deflate, br, zstd",
          "Accept-Language": "en-US,en;q=0.9",
          "Cookie": "__stripe_mid=ebfd26b6-c829-4742-8893-abaf894eb93edc4c96; colorMode=%22dark%22"
        },
        "protocol": "HTTP/1.1"
      },
      "id": 1,
      "thread_id": 0,
      "message": [
        {
          "name": "v",
          "value": "'b39bb78e'",
          "class": "String"
        }
      ]
    },
    {
      "event": "return",
      "http_server_response": {
        "status_code": 200,
        "headers": {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "text/javascript",
          "Cache-Control": "max-age=31536000,immutable",
          "Etag": "W/\"e99c-2FbwB9vOPYS+ZbLMWgVBPE/LHO8\""
        },
        "return_value": {
          "class": "[ResponseBody]",
          "value": "import {\n  __commonJS\n} from \"/node_modules/.vite/deps/chunk-4B2QHNJT.js?v=b39bb78e\";\n\n// node_modules/react-syntax-highlighter/node_modules/highlight.js/lib/core.js\nvar require_core = __commonJS({\n  \"node_modules/react-syntax-highlighter/node_modules/highlight.js/lib/core.js\"(exports, module) {\n    function deepFreeze(obj) {\n      if (obj instanceof Map) {\n        obj.clear = obj.delete = obj.set = function() {\n          throw new Error(\"map is read-only\");\n        };\n      } else if (obj instanceof Set) {\n        obj.add = obj.clear = obj.delete = function() {\n          throw new Error(\"set is read-only\");\n        };\n      }\n      Object.freeze(obj);\n      Object.getOwnPropertyNames(obj).forEach(function(name) {\n        var prop = obj[name];\n        if (typeof prop == \"object\" && !Object.isFrozen(prop)) {\n          deepFreeze(prop);\n        }\n      });\n      return obj;\n    }\n    var deepFreezeEs6 = deepFreeze;\n    var _default = deepFreeze;\n    deepFreezeEs6.default = _default;\n    var Response = class {\n      /**\n       * @param {CompiledMode} mode\n       */\n      constructor(mode) {\n        if (mode.data === void 0) mode.data = {};\n        this.data = mode.data;\n        this.isMatchIgnored = false;\n      }\n      ignoreMatch() {\n        this.isMatchIgnored = true;\n      }\n    };\n    function escapeHTML(value) {\n      return value.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#x27;\");\n    }\n    function inherit(original, ...objects) {\n      const result = /* @__PURE__ */ Object.create(null);\n      for (const key in original) {\n        result[key] = original[key];\n      }\n      objects.forEach(function(obj) {\n        for (const key in obj) {\n          result[key] = obj[key];\n        }\n      });\n      return (\n        /** @type {T} */\n        result\n      );\n    }\n    var SPAN_CLOSE = \"</span>\";\n    var emitsWrappingTags = (node) => {\n      return !!node.kind;\n    };\n    var HTMLRenderer = class {\n      /**\n       * Creates a new HTMLRenderer\n       *\n       * @param {Tree} parseTree - the parse tree (must support `walk` API)\n       * @param {{classPrefix: string}} options\n       */\n      constructor(parseTree, options) {\n        this.buffer = \"\";\n        this.classPrefix = options.classPrefix;\n        parseTree.walk(this);\n      }\n      /**\n       * Adds texts to the output stream\n       *\n       * @param {string} text */\n      addText(text) {\n        this.buffer += escapeHTML(text);\n      }\n      /**\n       * Adds a node open to the output stream (if needed)\n       *\n       * @param {Node} node */\n      openNode(node) {\n        if (!emitsWrappingTags(node)) return;\n        let className = node.kind;\n        if (!node.sublanguage) {\n          className = `${this.classPrefix}${className}`;\n        }\n        this.span(className);\n      }\n      /**\n       * Adds a node close to the output stream (if needed)\n       *\n       * @param {Node} node */\n      closeNode(node) {\n        if (!emitsWrappingTags(node)) return;\n        this.buffer += SPAN_CLOSE;\n      }\n      /**\n       * returns the accumulated buffer\n      */\n      value() {\n        return this.buffer;\n      }\n      // helpers\n      /**\n       * Builds a span element\n       *\n       * @param {string} className */\n      span(className) {\n        this.buffer += `<span class=\"${className}\">`;\n      }\n    };\n    var TokenTree = class _TokenTree {\n      constructor() {\n        this.rootNode = { children: [] };\n        this.stack = [this.rootNode];\n      }\n      get top() {\n        return this.stack[this.stack.length - 1];\n      }\n      get root() {\n        return this.rootNode;\n      }\n      /** @param {Node} node */\n      add(node) {\n        this.top.children.push(node);\n      }\n      /** @param {string} kind */\n      openNode(kind) {\n        const node = { kind, children: [] };\n        this.add(node);\n        this.stack.push(node);\n      }\n      closeNode() {\n        if (this.stack.length > 1) {\n          return this.stack.pop();\n        }\n        return void 0;\n      }\n      closeAllNodes() {\n        while (this.closeNode()) ;\n      }\n      toJSON() {\n        return JSON.stringify(this.rootNode, null, 4);\n      }\n      /**\n       * @typedef { import(\"./html_renderer\").Renderer } Renderer\n       * @param {Renderer} builder\n       */\n      walk(builder) {\n        return this.constructor._walk(builder, this.rootNode);\n      }\n      /**\n       * @param {Renderer} builder\n       * @param {Node} node\n       */\n      static _walk(builder, node) {\n        if (typeof node === \"string\") {\n          builder.addText(node);\n        } else if (node.children) {\n          builder.openNode(node);\n          node.children.forEach((child) => this._walk(builder, child));\n          builder.closeNode(node);\n        }\n        return builder;\n      }\n      /**\n       * @param {Node} node\n       */\n      static _collapse(node) {\n        if (typeof node === \"string\") return;\n        if (!node.children) return;\n        if (node.children.every((el) => typeof el === \"string\")) {\n          node.children = [node.children.join(\"\")];\n        } else {\n          node.children.forEach((child) => {\n            _TokenTree._collapse(child);\n          });\n        }\n      }\n    };\n    var TokenTreeEmitter = class extends TokenTree {\n      /**\n       * @param {*} options\n       */\n      constructor(options) {\n        super();\n        this.options = options;\n      }\n      /**\n       * @param {string} text\n       * @param {string} kind\n       */\n      addKeyword(text, kind) {\n        if (text === \"\") {\n          return;\n        }\n        this.openNode(kind);\n        this.addText(text);\n        this.closeNode();\n      }\n      /**\n       * @param {string} text\n       */\n      addText(text) {\n        if (text === \"\") {\n          return;\n        }\n        this.add(text);\n      }\n      /**\n       * @param {Emitter & {root: DataNode}} emitter\n       * @param {string} name\n       */\n      addSublanguage(emitter, name) {\n        const node = emitter.root;\n        node.kind = name;\n        node.sublanguage = true;\n        this.add(node);\n      }\n      toHTML() {\n        const renderer = new HTMLRenderer(this, this.options);\n        return renderer.value();\n      }\n      finalize() {\n        return true;\n      }\n    };\n    function escape(value) {\n      return new RegExp(value.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"), \"m\");\n    }\n    function source(re) {\n      if (!re) return null;\n      if (typeof re === \"string\") return re;\n      return re.source;\n    }\n    function concat(...args) {\n      const joined = args.map((x) => source(x)).join(\"\");\n      return joined;\n    }\n    function either(...args) {\n      const joined = \"(\" + args.map((x) => source(x)).join(\"|\") + \")\";\n      return joined;\n    }\n    function countMatchGroups(re) {\n      return new RegExp(re.toString() + \"|\").exec(\"\").length - 1;\n    }\n    function startsWith(re, lexeme) {\n      const match = re && re.exec(lexeme);\n      return match && match.index === 0;\n    }\n    var BACKREF_RE = /\\[(?:[^\\\\\\]]|\\\\.)*\\]|\\(\\??|\\\\([1-9][0-9]*)|\\\\./;\n    function join(regexps, separator = \"|\") {\n      let numCaptures = 0;\n      return regexps.map((regex) => {\n        numCaptures += 1;\n        const offset = numCaptures;\n        let re = source(regex);\n        let out = \"\";\n        while (re.length > 0) {\n          const match = BACKREF_RE.exec(re);\n          if (!match) {\n            out += re;\n            break;\n          }\n          out += re.substring(0, match.index);\n          re = re.substring(match.index + match[0].length);\n          if (match[0][0] === \"\\\\\" && match[1]) {\n            out += \"\\\\\" + String(Number(match[1]) + offset);\n          } else {\n            out += match[0];\n            if (match[0] === \"(\") {\n              numCaptures++;\n            }\n          }\n        }\n        return out;\n      }).map((re) => `(${re})`).join(separator);\n    }\n    var MATCH_NOTHING_RE = /\\b\\B/;\n    var IDENT_RE = \"[a-zA-Z]\\\\w*\";\n    var UNDERSCORE_IDENT_RE = \"[a-zA-Z_]\\\\w*\";\n    var NUMBER_RE = \"\\\\b\\\\d+(\\\\.\\\\d+)?\";\n    var C_NUMBER_RE = \"(-?)(\\\\b0[xX][a-fA-F0-9]+|(\\\\b\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][-+]?\\\\d+)?)\";\n    var BINARY_NUMBER_RE = \"\\\\b(0b[01]+)\";\n    var RE_STARTERS_RE = \"!|!=|!==|%|%=|&|&&|&=|\\\\*|\\\\*=|\\\\+|\\\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\\\?|\\\\[|\\\\{|\\\\(|\\\\^|\\\\^=|\\\\||\\\\|=|\\\\|\\\\||~\";\n    var SHEBANG = (opts = {}) => {\n      const beginShebang = /^#![ ]*\\//;\n      if (opts.binary) {\n        opts.begin = concat(\n          beginShebang,\n          /.*\\b/,\n          opts.binary,\n          /\\b.*/\n        );\n      }\n      return inherit({\n        className: \"meta\",\n        begin: beginShebang,\n        end: /$/,\n        relevance: 0,\n        /** @type {ModeCallback} */\n        \"on:begin\": (m, resp) => {\n          if (m.index !== 0) resp.ignoreMatch();\n        }\n      }, opts);\n    };\n    var BACKSLASH_ESCAPE = {\n      begin: \"\\\\\\\\[\\\\s\\\\S]\",\n      relevance: 0\n    };\n    var APOS_STRING_MODE = {\n      className: \"string\",\n      begin: \"'\",\n      end: \"'\",\n      illegal: \"\\\\n\",\n      contains: [BACKSLASH_ESCAPE]\n    };\n    var QUOTE_STRING_MODE = {\n      className: \"string\",\n      begin: '\"',\n      end: '\"',\n      illegal: \"\\\\n\",\n      contains: [BACKSLASH_ESCAPE]\n    };\n    var PHRASAL_WORDS_MODE = {\n      begin: /\\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\\b/\n    };\n    var COMMENT = function(begin, end, modeOptions = {}) {\n      const mode = inherit(\n        {\n          className: \"comment\",\n          begin,\n          end,\n          contains: []\n        },\n        modeOptions\n      );\n      mode.contains.push(PHRASAL_WORDS_MODE);\n      mode.contains.push({\n        className: \"doctag\",\n        begin: \"(?:TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):\",\n        relevance: 0\n      });\n      return mode;\n    };\n    var C_LINE_COMMENT_MODE = COMMENT(\"//\", \"$\");\n    var C_BLOCK_COMMENT_MODE = COMMENT... (49804 more characters)"
        }
      },
      "id": 2,
      "thread_id": 0,
      "parent_id": 1,
      "elapsed": 0.00018337497022002935
    }
  ],
  "version": "1.12",
  "metadata": {
    "client": {
      "name": "appmap-node",
      "version": "2.23.1",
      "url": "https://github.com/getappmap/appmap-node"
    },
    "language": {
      "name": "javascript",
      "engine": "Node.js",
      "version": "v20.15.1"
    },
    "app": "MyApp",
    "recorder": {
      "type": "requests",
      "name": "requests"
    },
    "name": "GET /node_modules/.vite/deps/chunk-U5KJ3HQ7.js (200) â€” 2024-07-28T11:41:40.348Z"
  },
  "classMap": [
    {
      "type": "http",
      "name": "HTTP server requests",
      "children": [
        {
          "type": "route",
          "name": "GET /node_modules/.vite/deps/chunk-U5KJ3HQ7.js"
        }
      ]
    }
  ]
}