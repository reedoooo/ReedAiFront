{
  "events": [
    {
      "event": "call",
      "http_server_request": {
        "path_info": "/node_modules/.vite/deps/chunk-3FZAEXWV.js",
        "request_method": "GET",
        "headers": {
          "Host": "localhost:3000",
          "Connection": "keep-alive",
          "Sec-Ch-Ua": "\"Not/A)Brand\";v=\"8\", \"Chromium\";v=\"126\", \"Google Chrome\";v=\"126\"",
          "Origin": "http://localhost:3000",
          "Sec-Ch-Ua-Mobile": "?0",
          "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
          "Sec-Ch-Ua-Platform": "\"macOS\"",
          "Accept": "*/*",
          "Sec-Fetch-Site": "same-origin",
          "Sec-Fetch-Mode": "cors",
          "Sec-Fetch-Dest": "script",
          "Referer": "http://localhost:3000/node_modules/.vite/deps/@tiptap_starter-kit.js?v=53a4e46e",
          "Accept-Encoding": "gzip, deflate, br, zstd",
          "Accept-Language": "en-US,en;q=0.9",
          "Cookie": "__stripe_mid=ebfd26b6-c829-4742-8893-abaf894eb93edc4c96; colorMode=%22dark%22"
        },
        "protocol": "HTTP/1.1"
      },
      "id": 1,
      "thread_id": 0,
      "message": [
        {
          "name": "v",
          "value": "'b39bb78e'",
          "class": "String"
        }
      ]
    },
    {
      "event": "return",
      "http_server_response": {
        "status_code": 200,
        "headers": {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "text/javascript",
          "Cache-Control": "max-age=31536000,immutable",
          "Etag": "W/\"87589-P6FYVHVWHceH8r8NLFpKKXFxLXM\""
        },
        "return_value": {
          "class": "[ResponseBody]",
          "value": "// node_modules/orderedmap/dist/index.js\nfunction OrderedMap(content) {\n  this.content = content;\n}\nOrderedMap.prototype = {\n  constructor: OrderedMap,\n  find: function(key) {\n    for (var i = 0; i < this.content.length; i += 2)\n      if (this.content[i] === key) return i;\n    return -1;\n  },\n  // :: (string) → ?any\n  // Retrieve the value stored under `key`, or return undefined when\n  // no such key exists.\n  get: function(key) {\n    var found2 = this.find(key);\n    return found2 == -1 ? void 0 : this.content[found2 + 1];\n  },\n  // :: (string, any, ?string) → OrderedMap\n  // Create a new map by replacing the value of `key` with a new\n  // value, or adding a binding to the end of the map. If `newKey` is\n  // given, the key of the binding will be replaced with that key.\n  update: function(key, value, newKey) {\n    var self = newKey && newKey != key ? this.remove(newKey) : this;\n    var found2 = self.find(key), content = self.content.slice();\n    if (found2 == -1) {\n      content.push(newKey || key, value);\n    } else {\n      content[found2 + 1] = value;\n      if (newKey) content[found2] = newKey;\n    }\n    return new OrderedMap(content);\n  },\n  // :: (string) → OrderedMap\n  // Return a map with the given key removed, if it existed.\n  remove: function(key) {\n    var found2 = this.find(key);\n    if (found2 == -1) return this;\n    var content = this.content.slice();\n    content.splice(found2, 2);\n    return new OrderedMap(content);\n  },\n  // :: (string, any) → OrderedMap\n  // Add a new key to the start of the map.\n  addToStart: function(key, value) {\n    return new OrderedMap([key, value].concat(this.remove(key).content));\n  },\n  // :: (string, any) → OrderedMap\n  // Add a new key to the end of the map.\n  addToEnd: function(key, value) {\n    var content = this.remove(key).content.slice();\n    content.push(key, value);\n    return new OrderedMap(content);\n  },\n  // :: (string, string, any) → OrderedMap\n  // Add a key after the given key. If `place` is not found, the new\n  // key is added to the end.\n  addBefore: function(place, key, value) {\n    var without = this.remove(key), content = without.content.slice();\n    var found2 = without.find(place);\n    content.splice(found2 == -1 ? content.length : found2, 0, key, value);\n    return new OrderedMap(content);\n  },\n  // :: ((key: string, value: any))\n  // Call the given function for each key/value pair in the map, in\n  // order.\n  forEach: function(f) {\n    for (var i = 0; i < this.content.length; i += 2)\n      f(this.content[i], this.content[i + 1]);\n  },\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by prepending the keys in this map that don't\n  // appear in `map` before the keys in `map`.\n  prepend: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this;\n    return new OrderedMap(map.content.concat(this.subtract(map).content));\n  },\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by appending the keys in this map that don't\n  // appear in `map` after the keys in `map`.\n  append: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this;\n    return new OrderedMap(this.subtract(map).content.concat(map.content));\n  },\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a map containing all the keys in this map that don't\n  // appear in `map`.\n  subtract: function(map) {\n    var result = this;\n    map = OrderedMap.from(map);\n    for (var i = 0; i < map.content.length; i += 2)\n      result = result.remove(map.content[i]);\n    return result;\n  },\n  // :: () → Object\n  // Turn ordered map into a plain object.\n  toObject: function() {\n    var result = {};\n    this.forEach(function(key, value) {\n      result[key] = value;\n    });\n    return result;\n  },\n  // :: number\n  // The amount of keys in this map.\n  get size() {\n    return this.content.length >> 1;\n  }\n};\nOrderedMap.from = function(value) {\n  if (value instanceof OrderedMap) return value;\n  var content = [];\n  if (value) for (var prop in value) content.push(prop, value[prop]);\n  return new OrderedMap(content);\n};\nvar dist_default = OrderedMap;\n\n// node_modules/prosemirror-model/dist/index.js\nfunction findDiffStart(a, b, pos) {\n  for (let i = 0; ; i++) {\n    if (i == a.childCount || i == b.childCount)\n      return a.childCount == b.childCount ? null : pos;\n    let childA = a.child(i), childB = b.child(i);\n    if (childA == childB) {\n      pos += childA.nodeSize;\n      continue;\n    }\n    if (!childA.sameMarkup(childB))\n      return pos;\n    if (childA.isText && childA.text != childB.text) {\n      for (let j = 0; childA.text[j] == childB.text[j]; j++)\n        pos++;\n      return pos;\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffStart(childA.content, childB.content, pos + 1);\n      if (inner != null)\n        return inner;\n    }\n    pos += childA.nodeSize;\n  }\n}\nfunction findDiffEnd(a, b, posA, posB) {\n  for (let iA = a.childCount, iB = b.childCount; ; ) {\n    if (iA == 0 || iB == 0)\n      return iA == iB ? null : { a: posA, b: posB };\n    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;\n    if (childA == childB) {\n      posA -= size;\n      posB -= size;\n      continue;\n    }\n    if (!childA.sameMarkup(childB))\n      return { a: posA, b: posB };\n    if (childA.isText && childA.text != childB.text) {\n      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++;\n        posA--;\n        posB--;\n      }\n      return { a: posA, b: posB };\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n      if (inner)\n        return inner;\n    }\n    posA -= size;\n    posB -= size;\n  }\n}\nvar Fragment = class _Fragment {\n  /**\n  @internal\n  */\n  constructor(content, size) {\n    this.content = content;\n    this.size = size || 0;\n    if (size == null)\n      for (let i = 0; i < content.length; i++)\n        this.size += content[i].nodeSize;\n  }\n  /**\n  Invoke a callback for all descendant nodes between the given two\n  positions (relative to start of this fragment). Doesn't descend\n  into a node when the callback returns `false`.\n  */\n  nodesBetween(from, to, f, nodeStart = 0, parent) {\n    for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize;\n      if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {\n        let start = pos + 1;\n        child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);\n      }\n      pos = end;\n    }\n  }\n  /**\n  Call the given callback for every descendant node. `pos` will be\n  relative to the start of the fragment. The callback may return\n  `false` to prevent traversal of a given node's children.\n  */\n  descendants(f) {\n    this.nodesBetween(0, this.size, f);\n  }\n  /**\n  Extract the text between `from` and `to`. See the same method on\n  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).\n  */\n  textBetween(from, to, blockSeparator, leafText) {\n    let text = \"\", first2 = true;\n    this.nodesBetween(from, to, (node, pos) => {\n      let nodeText = node.isText ? node.text.slice(Math.max(from, pos) - pos, to - pos) : !node.isLeaf ? \"\" : leafText ? typeof leafText === \"function\" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : \"\";\n      if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {\n        if (first2)\n          first2 = false;\n        else\n          text += blockSeparator;\n      }\n      text += nodeText;\n    }, 0);\n    return text;\n  }\n  /**\n  Create a new fragment containing the combined content of this\n  fragment and the other.\n  */\n  append(other) {\n    if (!other.size)\n      return this;\n    if (!this.size)\n      return other;\n    let last = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i = 0;\n    if (last.isText && last.sameMarkup(first2)) {\n      content[content.length - 1] = last.withText(last.text + first2.text);\n      i = 1;\n    }\n    for (; i < other.content.length; i++)\n      content.push(other.content[i]);\n    return new _Fragment(content, this.size + other.size);\n  }\n  /**\n  Cut out the sub-fragment between the two given positions.\n  */\n  cut(from, to = this.size) {\n    if (from == 0 && to == this.size)\n      return this;\n    let result = [], size = 0;\n    if (to > from)\n      for (let i = 0, pos = 0; pos < to; i++) {\n        let child = this.content[i], end = pos + child.nodeSize;\n        if (end > from) {\n          if (pos < from || end > to) {\n            if (child.isText)\n              child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));\n            else\n              child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));\n          }\n          result.push(child);\n          size += child.nodeSize;\n        }\n        pos = end;\n      }\n    return new _Fragment(result, size);\n  }\n  /**\n  @internal\n  */\n  cutByIndex(from, to) {\n    if (from == to)\n      return _Fragment.empty;\n    if (from == 0 && to == this.content.length)\n      return this;\n    return new _Fragment(this.content.slice(from, to));\n  }\n  /**\n  Create a new fragment in which the node at the given index is\n  replaced by the given node.\n  */\n  replaceChild(index2, node) {\n    let current = this.content[index2];\n    if (current == node)\n      return this;\n    let copy2 = this.content.slice();\n    let size = this.size + node.nodeSize - current.nodeSize;\n    copy2[index2] = node;\n    return new _Fragment(copy2, size);\n  }\n  /**\n  Create a new fragment by prepending the given node to this\n  fragment.\n  */\n  addToStart(node) {\n    return new _Fragment([node].concat(this.content), this.size + node.nodeSize);\n ... (544333 more characters)"
        }
      },
      "id": 2,
      "thread_id": 0,
      "parent_id": 1,
      "elapsed": 0.004377665929496288
    }
  ],
  "version": "1.12",
  "metadata": {
    "client": {
      "name": "appmap-node",
      "version": "2.23.1",
      "url": "https://github.com/getappmap/appmap-node"
    },
    "language": {
      "name": "javascript",
      "engine": "Node.js",
      "version": "v20.15.1"
    },
    "app": "MyApp",
    "recorder": {
      "type": "requests",
      "name": "requests"
    },
    "name": "GET /node_modules/.vite/deps/chunk-3FZAEXWV.js (200) — 2024-07-28T11:41:33.855Z"
  },
  "classMap": [
    {
      "type": "http",
      "name": "HTTP server requests",
      "children": [
        {
          "type": "route",
          "name": "GET /node_modules/.vite/deps/chunk-3FZAEXWV.js"
        }
      ]
    }
  ]
}