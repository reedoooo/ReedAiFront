{
  "events": [
    {
      "event": "call",
      "http_server_request": {
        "path_info": "/node_modules/.vite/deps/chunk-JLHFKP3S.js",
        "request_method": "GET",
        "headers": {
          "Host": "localhost:3000",
          "Connection": "keep-alive",
          "Sec-Ch-Ua": "\"Not/A)Brand\";v=\"8\", \"Chromium\";v=\"126\", \"Google Chrome\";v=\"126\"",
          "Origin": "http://localhost:3000",
          "Sec-Ch-Ua-Mobile": "?0",
          "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
          "Sec-Ch-Ua-Platform": "\"macOS\"",
          "Accept": "*/*",
          "Sec-Fetch-Site": "same-origin",
          "Sec-Fetch-Mode": "cors",
          "Sec-Fetch-Dest": "script",
          "Referer": "http://localhost:3000/node_modules/.vite/deps/react-syntax-highlighter.js?v=69cd69d1",
          "Accept-Encoding": "gzip, deflate, br, zstd",
          "Accept-Language": "en-US,en;q=0.9",
          "Cookie": "__stripe_mid=ebfd26b6-c829-4742-8893-abaf894eb93edc4c96; colorMode=%22dark%22"
        },
        "protocol": "HTTP/1.1"
      },
      "id": 1,
      "thread_id": 0,
      "message": [
        {
          "name": "v",
          "value": "'b39bb78e'",
          "class": "String"
        }
      ]
    },
    {
      "event": "return",
      "http_server_response": {
        "status_code": 200,
        "headers": {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "text/javascript",
          "Cache-Control": "max-age=31536000,immutable",
          "Etag": "W/\"4524-RDxOkPiNwUowf/0mRvl7j/dwhtA\""
        },
        "return_value": {
          "class": "[ResponseBody]",
          "value": "import {\n  __commonJS\n} from \"/node_modules/.vite/deps/chunk-4B2QHNJT.js?v=b39bb78e\";\n\n// node_modules/react-syntax-highlighter/node_modules/highlight.js/lib/languages/typescript.js\nvar require_typescript = __commonJS({\n  \"node_modules/react-syntax-highlighter/node_modules/highlight.js/lib/languages/typescript.js\"(exports, module) {\n    var IDENT_RE = \"[A-Za-z$_][0-9A-Za-z$_]*\";\n    var KEYWORDS = [\n      \"as\",\n      // for exports\n      \"in\",\n      \"of\",\n      \"if\",\n      \"for\",\n      \"while\",\n      \"finally\",\n      \"var\",\n      \"new\",\n      \"function\",\n      \"do\",\n      \"return\",\n      \"void\",\n      \"else\",\n      \"break\",\n      \"catch\",\n      \"instanceof\",\n      \"with\",\n      \"throw\",\n      \"case\",\n      \"default\",\n      \"try\",\n      \"switch\",\n      \"continue\",\n      \"typeof\",\n      \"delete\",\n      \"let\",\n      \"yield\",\n      \"const\",\n      \"class\",\n      // JS handles these with a special rule\n      // \"get\",\n      // \"set\",\n      \"debugger\",\n      \"async\",\n      \"await\",\n      \"static\",\n      \"import\",\n      \"from\",\n      \"export\",\n      \"extends\"\n    ];\n    var LITERALS = [\n      \"true\",\n      \"false\",\n      \"null\",\n      \"undefined\",\n      \"NaN\",\n      \"Infinity\"\n    ];\n    var TYPES = [\n      \"Intl\",\n      \"DataView\",\n      \"Number\",\n      \"Math\",\n      \"Date\",\n      \"String\",\n      \"RegExp\",\n      \"Object\",\n      \"Function\",\n      \"Boolean\",\n      \"Error\",\n      \"Symbol\",\n      \"Set\",\n      \"Map\",\n      \"WeakSet\",\n      \"WeakMap\",\n      \"Proxy\",\n      \"Reflect\",\n      \"JSON\",\n      \"Promise\",\n      \"Float64Array\",\n      \"Int16Array\",\n      \"Int32Array\",\n      \"Int8Array\",\n      \"Uint16Array\",\n      \"Uint32Array\",\n      \"Float32Array\",\n      \"Array\",\n      \"Uint8Array\",\n      \"Uint8ClampedArray\",\n      \"ArrayBuffer\",\n      \"BigInt64Array\",\n      \"BigUint64Array\",\n      \"BigInt\"\n    ];\n    var ERROR_TYPES = [\n      \"EvalError\",\n      \"InternalError\",\n      \"RangeError\",\n      \"ReferenceError\",\n      \"SyntaxError\",\n      \"TypeError\",\n      \"URIError\"\n    ];\n    var BUILT_IN_GLOBALS = [\n      \"setInterval\",\n      \"setTimeout\",\n      \"clearInterval\",\n      \"clearTimeout\",\n      \"require\",\n      \"exports\",\n      \"eval\",\n      \"isFinite\",\n      \"isNaN\",\n      \"parseFloat\",\n      \"parseInt\",\n      \"decodeURI\",\n      \"decodeURIComponent\",\n      \"encodeURI\",\n      \"encodeURIComponent\",\n      \"escape\",\n      \"unescape\"\n    ];\n    var BUILT_IN_VARIABLES = [\n      \"arguments\",\n      \"this\",\n      \"super\",\n      \"console\",\n      \"window\",\n      \"document\",\n      \"localStorage\",\n      \"module\",\n      \"global\"\n      // Node.js\n    ];\n    var BUILT_INS = [].concat(\n      BUILT_IN_GLOBALS,\n      BUILT_IN_VARIABLES,\n      TYPES,\n      ERROR_TYPES\n    );\n    function source(re) {\n      if (!re) return null;\n      if (typeof re === \"string\") return re;\n      return re.source;\n    }\n    function lookahead(re) {\n      return concat(\"(?=\", re, \")\");\n    }\n    function concat(...args) {\n      const joined = args.map((x) => source(x)).join(\"\");\n      return joined;\n    }\n    function javascript(hljs) {\n      const hasClosingTag = (match, { after }) => {\n        const tag = \"</\" + match[0].slice(1);\n        const pos = match.input.indexOf(tag, after);\n        return pos !== -1;\n      };\n      const IDENT_RE$1 = IDENT_RE;\n      const FRAGMENT = {\n        begin: \"<>\",\n        end: \"</>\"\n      };\n      const XML_TAG = {\n        begin: /<[A-Za-z0-9\\\\._:-]+/,\n        end: /\\/[A-Za-z0-9\\\\._:-]+>|\\/>/,\n        /**\n         * @param {RegExpMatchArray} match\n         * @param {CallbackResponse} response\n         */\n        isTrulyOpeningTag: (match, response) => {\n          const afterMatchIndex = match[0].length + match.index;\n          const nextChar = match.input[afterMatchIndex];\n          if (nextChar === \"<\") {\n            response.ignoreMatch();\n            return;\n          }\n          if (nextChar === \">\") {\n            if (!hasClosingTag(match, { after: afterMatchIndex })) {\n              response.ignoreMatch();\n            }\n          }\n        }\n      };\n      const KEYWORDS$1 = {\n        $pattern: IDENT_RE,\n        keyword: KEYWORDS,\n        literal: LITERALS,\n        built_in: BUILT_INS\n      };\n      const decimalDigits = \"[0-9](_?[0-9])*\";\n      const frac = `\\\\.(${decimalDigits})`;\n      const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;\n      const NUMBER = {\n        className: \"number\",\n        variants: [\n          // DecimalLiteral\n          { begin: `(\\\\b(${decimalInteger})((${frac})|\\\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\\\b` },\n          { begin: `\\\\b(${decimalInteger})\\\\b((${frac})\\\\b|\\\\.)?|(${frac})\\\\b` },\n          // DecimalBigIntegerLiteral\n          { begin: `\\\\b(0|[1-9](_?[0-9])*)n\\\\b` },\n          // NonDecimalIntegerLiteral\n          { begin: \"\\\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\\\b\" },\n          { begin: \"\\\\b0[bB][0-1](_?[0-1])*n?\\\\b\" },\n          { begin: \"\\\\b0[oO][0-7](_?[0-7])*n?\\\\b\" },\n          // LegacyOctalIntegerLiteral (does not include underscore separators)\n          // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals\n          { begin: \"\\\\b0[0-7]+n?\\\\b\" }\n        ],\n        relevance: 0\n      };\n      const SUBST = {\n        className: \"subst\",\n        begin: \"\\\\$\\\\{\",\n        end: \"\\\\}\",\n        keywords: KEYWORDS$1,\n        contains: []\n        // defined later\n      };\n      const HTML_TEMPLATE = {\n        begin: \"html`\",\n        end: \"\",\n        starts: {\n          end: \"`\",\n          returnEnd: false,\n          contains: [\n            hljs.BACKSLASH_ESCAPE,\n            SUBST\n          ],\n          subLanguage: \"xml\"\n        }\n      };\n      const CSS_TEMPLATE = {\n        begin: \"css`\",\n        end: \"\",\n        starts: {\n          end: \"`\",\n          returnEnd: false,\n          contains: [\n            hljs.BACKSLASH_ESCAPE,\n            SUBST\n          ],\n          subLanguage: \"css\"\n        }\n      };\n      const TEMPLATE_STRING = {\n        className: \"string\",\n        begin: \"`\",\n        end: \"`\",\n        contains: [\n          hljs.BACKSLASH_ESCAPE,\n          SUBST\n        ]\n      };\n      const JSDOC_COMMENT = hljs.COMMENT(\n        /\\/\\*\\*(?!\\/)/,\n        \"\\\\*/\",\n        {\n          relevance: 0,\n          contains: [\n            {\n              className: \"doctag\",\n              begin: \"@[A-Za-z]+\",\n              contains: [\n                {\n                  className: \"type\",\n                  begin: \"\\\\{\",\n                  end: \"\\\\}\",\n                  relevance: 0\n                },\n                {\n                  className: \"variable\",\n                  begin: IDENT_RE$1 + \"(?=\\\\s*(-)|$)\",\n                  endsParent: true,\n                  relevance: 0\n                },\n                // eat spaces (not newlines) so we can find\n                // types or variables\n                {\n                  begin: /(?=[^\\n])\\s/,\n                  relevance: 0\n                }\n              ]\n            }\n          ]\n        }\n      );\n      const COMMENT = {\n        className: \"comment\",\n        variants: [\n          JSDOC_COMMENT,\n          hljs.C_BLOCK_COMMENT_MODE,\n          hljs.C_LINE_COMMENT_MODE\n        ]\n      };\n      const SUBST_INTERNALS = [\n        hljs.APOS_STRING_MODE,\n        hljs.QUOTE_STRING_MODE,\n        HTML_TEMPLATE,\n        CSS_TEMPLATE,\n        TEMPLATE_STRING,\n        NUMBER,\n        hljs.REGEXP_MODE\n      ];\n      SUBST.contains = SUBST_INTERNALS.concat({\n        // we need to pair up {} inside our subst to prevent\n        // it from ending too early by matching another }\n        begin: /\\{/,\n        end: /\\}/,\n        keywords: KEYWORDS$1,\n        contains: [\n          \"self\"\n        ].concat(SUBST_INTERNALS)\n      });\n      const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);\n      const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([\n        // eat recursive parens in sub expressions\n        {\n          begin: /\\(/,\n          end: /\\)/,\n          keywords: KEYWORDS$1,\n          contains: [\"self\"].concat(SUBST_AND_COMMENTS)\n        }\n      ]);\n      const PARAMS = {\n        className: \"params\",\n        begin: /\\(/,\n        end: /\\)/,\n        excludeBegin: true,\n        excludeEnd: true,\n        keywords: KEYWORDS$1,\n        contains: PARAMS_CONTAINS\n      };\n      return {\n        name: \"Javascript\",\n        aliases: [\"js\", \"jsx\", \"mjs\", \"cjs\"],\n        keywords: KEYWORDS$1,\n        // this will be extended by TypeScript\n        exports: { PARAMS_CONTAINS },\n        illegal: /#(?![$_A-z])/,\n        contains: [\n          hljs.SHEBANG({\n            label: \"shebang\",\n            binary: \"node\",\n            relevance: 5\n          }),\n          {\n            label: \"use_strict\",\n            className: \"meta\",\n            relevance: 10,\n            begin: /^\\s*['\"]use (strict|asm)['\"]/\n          },\n          hljs.APOS_STRING_MODE,\n          hljs.QUOTE_STRING_MODE,\n          HTML_TEMPLATE,\n          CSS_TEMPLATE,\n          TEMPLATE_STRING,\n          COMMENT,\n          NUMBER,\n          {\n            // object attr container\n            begin: concat(\n              /[{,\\n]\\s*/,\n              // we need to look ahead to make sure that we actually have an\n              // attribute coming up so we don't steal a comma from a potential\n              // \"value\" container\n              //\n              // NOTE: this might not work how you think.  We don't actually always\n              // enter this mode and stay.  Instead it might merely match `,\n              // <comments up next>` and then immediately end after the , because it\n              // fails to find any actual attrs. But this still does the job because\n              // it prevents the value contain rule from grabbing this instead and\n              // prevening this rule from firing when we actually DO have keys.\n              lookahead(concat(\n                // we also need to allow for multiple possible comments inbetween\n                // the first key:value pairing\n                /(((\\/\\/.*$)|(\\/\\*(\\*[^/]|[^*])*\\*\\/))\\s*)*/,\n                IDENT_RE$1 + \"\\\\... (7700 more characters)"
        }
      },
      "id": 2,
      "thread_id": 0,
      "parent_id": 1,
      "elapsed": 0.00028612499590963125
    }
  ],
  "version": "1.12",
  "metadata": {
    "client": {
      "name": "appmap-node",
      "version": "2.23.1",
      "url": "https://github.com/getappmap/appmap-node"
    },
    "language": {
      "name": "javascript",
      "engine": "Node.js",
      "version": "v20.15.1"
    },
    "app": "MyApp",
    "recorder": {
      "type": "requests",
      "name": "requests"
    },
    "name": "GET /node_modules/.vite/deps/chunk-JLHFKP3S.js (200) â€” 2024-07-28T11:41:34.937Z"
  },
  "classMap": [
    {
      "type": "http",
      "name": "HTTP server requests",
      "children": [
        {
          "type": "route",
          "name": "GET /node_modules/.vite/deps/chunk-JLHFKP3S.js"
        }
      ]
    }
  ]
}