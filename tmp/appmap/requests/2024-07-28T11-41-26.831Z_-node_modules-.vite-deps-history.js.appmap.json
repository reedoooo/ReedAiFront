{
  "events": [
    {
      "event": "call",
      "http_server_request": {
        "path_info": "/node_modules/.vite/deps/history.js",
        "request_method": "GET",
        "headers": {
          "Host": "localhost:3000",
          "Connection": "keep-alive",
          "Sec-Ch-Ua": "\"Not/A)Brand\";v=\"8\", \"Chromium\";v=\"126\", \"Google Chrome\";v=\"126\"",
          "Origin": "http://localhost:3000",
          "Sec-Ch-Ua-Mobile": "?0",
          "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
          "Sec-Ch-Ua-Platform": "\"macOS\"",
          "Accept": "*/*",
          "Sec-Fetch-Site": "same-origin",
          "Sec-Fetch-Mode": "cors",
          "Sec-Fetch-Dest": "script",
          "Referer": "http://localhost:3000/src/routes/index.jsx",
          "Accept-Encoding": "gzip, deflate, br, zstd",
          "Accept-Language": "en-US,en;q=0.9",
          "Cookie": "__stripe_mid=ebfd26b6-c829-4742-8893-abaf894eb93edc4c96; colorMode=%22dark%22"
        },
        "protocol": "HTTP/1.1"
      },
      "id": 1,
      "thread_id": 0,
      "message": [
        {
          "name": "v",
          "value": "'bf9d19bd'",
          "class": "String"
        }
      ]
    },
    {
      "event": "return",
      "http_server_response": {
        "status_code": 200,
        "headers": {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "text/javascript",
          "Cache-Control": "max-age=31536000,immutable",
          "Etag": "W/\"4552-cCumFift2+XCg5+kvxWdqsuEo5Y\""
        },
        "return_value": {
          "class": "[ResponseBody]",
          "value": "import {\n  _extends,\n  init_extends\n} from \"/node_modules/.vite/deps/chunk-QZVMM6GT.js?v=b39bb78e\";\nimport \"/node_modules/.vite/deps/chunk-4B2QHNJT.js?v=b39bb78e\";\n\n// node_modules/history/index.js\ninit_extends();\nvar Action;\n(function(Action2) {\n  Action2[\"Pop\"] = \"POP\";\n  Action2[\"Push\"] = \"PUSH\";\n  Action2[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\nvar readOnly = true ? function(obj) {\n  return Object.freeze(obj);\n} : function(obj) {\n  return obj;\n};\nfunction warning(cond, message) {\n  if (!cond) {\n    if (typeof console !== \"undefined\") console.warn(message);\n    try {\n      throw new Error(message);\n    } catch (e) {\n    }\n  }\n}\nvar BeforeUnloadEventType = \"beforeunload\";\nvar HashChangeEventType = \"hashchange\";\nvar PopStateEventType = \"popstate\";\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _options = options, _options$window = _options.window, window = _options$window === void 0 ? document.defaultView : _options$window;\n  var globalHistory = window.history;\n  function getIndexAndLocation() {\n    var _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash;\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname,\n      search,\n      hash,\n      state: state.usr || null,\n      key: state.key || \"default\"\n    })];\n  }\n  var blockedPopTx = null;\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n      var _getIndexAndLocation = getIndexAndLocation(), nextIndex = _getIndexAndLocation[0], nextLocation = _getIndexAndLocation[1];\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n          if (delta) {\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          true ? warning(\n            false,\n            // TODO: Write up a doc that explains our blocking strategy in\n            // detail and link to it here so people can understand better what\n            // is going on and how to avoid it.\n            \"You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.\"\n          ) : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n  window.addEventListener(PopStateEventType, handlePop);\n  var action = Action.Pop;\n  var _getIndexAndLocation2 = getIndexAndLocation(), index = _getIndexAndLocation2[0], location = _getIndexAndLocation2[1];\n  var listeners = createEvents();\n  var blockers = createEvents();\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), \"\");\n  }\n  function createHref(to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: \"\",\n      search: \"\"\n    }, typeof to === \"string\" ? parsePath(to) : to, {\n      state,\n      key: createKey()\n    }));\n  }\n  function getHistoryStateAndUrl(nextLocation, index2) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index2\n    }, createHref(nextLocation)];\n  }\n  function allowTx(action2, location2, retry) {\n    return !blockers.length || (blockers.call({\n      action: action2,\n      location: location2,\n      retry\n    }), false);\n  }\n  function applyTx(nextAction) {\n    action = nextAction;\n    var _getIndexAndLocation3 = getIndexAndLocation();\n    index = _getIndexAndLocation3[0];\n    location = _getIndexAndLocation3[1];\n    listeners.call({\n      action,\n      location\n    });\n  }\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n    function retry() {\n      push(to, state);\n    }\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1), historyState = _getHistoryStateAndUr[0], url = _getHistoryStateAndUr[1];\n      try {\n        globalHistory.pushState(historyState, \"\", url);\n      } catch (error) {\n        window.location.assign(url);\n      }\n      applyTx(nextAction);\n    }\n  }\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n    function retry() {\n      replace(to, state);\n    }\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index), historyState = _getHistoryStateAndUr2[0], url = _getHistoryStateAndUr2[1];\n      globalHistory.replaceState(historyState, \"\", url);\n      applyTx(nextAction);\n    }\n  }\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n  var history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return location;\n    },\n    createHref,\n    push,\n    replace,\n    go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n      return function() {\n        unblock();\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _options2 = options, _options2$window = _options2.window, window = _options2$window === void 0 ? document.defaultView : _options2$window;\n  var globalHistory = window.history;\n  function getIndexAndLocation() {\n    var _parsePath = parsePath(window.location.hash.substr(1)), _parsePath$pathname = _parsePath.pathname, pathname = _parsePath$pathname === void 0 ? \"/\" : _parsePath$pathname, _parsePath$search = _parsePath.search, search = _parsePath$search === void 0 ? \"\" : _parsePath$search, _parsePath$hash = _parsePath.hash, hash = _parsePath$hash === void 0 ? \"\" : _parsePath$hash;\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname,\n      search,\n      hash,\n      state: state.usr || null,\n      key: state.key || \"default\"\n    })];\n  }\n  var blockedPopTx = null;\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n      var _getIndexAndLocation4 = getIndexAndLocation(), nextIndex = _getIndexAndLocation4[0], nextLocation = _getIndexAndLocation4[1];\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n          if (delta) {\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          true ? warning(\n            false,\n            // TODO: Write up a doc that explains our blocking strategy in\n            // detail and link to it here so people can understand better\n            // what is going on and how to avoid it.\n            \"You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.\"\n          ) : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n  window.addEventListener(PopStateEventType, handlePop);\n  window.addEventListener(HashChangeEventType, function() {\n    var _getIndexAndLocation5 = getIndexAndLocation(), nextLocation = _getIndexAndLocation5[1];\n    if (createPath(nextLocation) !== createPath(location)) {\n      handlePop();\n    }\n  });\n  var action = Action.Pop;\n  var _getIndexAndLocation6 = getIndexAndLocation(), index = _getIndexAndLocation6[0], location = _getIndexAndLocation6[1];\n  var listeners = createEvents();\n  var blockers = createEvents();\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), \"\");\n  }\n  function getBaseHref() {\n    var base = document.querySelector(\"base\");\n    var href = \"\";\n    if (base && base.getAttribute(\"href\")) {\n      var url = window.location.href;\n      var hashIndex = url.indexOf(\"#\");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n    return href;\n  }\n  function createHref(to) {\n    return getBaseHref() + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n  }\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: \"\",\n      search: \"\"\n    }, typeof to === \"string\" ? parsePath(to) : to, {\n      state,\n      key: createKey()\n    }));\n  }\n  function getHistoryStateAndUrl(nextLocation, index2) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index2\n    }, createHref(nextLocation)];\n  }\n  function allowTx(action2, location2, retry) {\n    return !blockers.length || (blockers.call({\n      action: action2,\n      location: location2,\n      retry\n    }), false);\n  }\n  functio... (7746 more characters)"
        }
      },
      "id": 2,
      "thread_id": 0,
      "parent_id": 1,
      "elapsed": 0.00046258303336799145
    }
  ],
  "version": "1.12",
  "metadata": {
    "client": {
      "name": "appmap-node",
      "version": "2.23.1",
      "url": "https://github.com/getappmap/appmap-node"
    },
    "language": {
      "name": "javascript",
      "engine": "Node.js",
      "version": "v20.15.1"
    },
    "app": "MyApp",
    "recorder": {
      "type": "requests",
      "name": "requests"
    },
    "name": "GET /node_modules/.vite/deps/history.js (200) — 2024-07-28T11:41:26.831Z"
  },
  "classMap": [
    {
      "type": "http",
      "name": "HTTP server requests",
      "children": [
        {
          "type": "route",
          "name": "GET /node_modules/.vite/deps/history.js"
        }
      ]
    }
  ]
}