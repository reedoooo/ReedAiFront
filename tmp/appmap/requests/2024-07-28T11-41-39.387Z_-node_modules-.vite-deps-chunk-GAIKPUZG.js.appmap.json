{
  "events": [
    {
      "event": "call",
      "http_server_request": {
        "path_info": "/node_modules/.vite/deps/chunk-GAIKPUZG.js",
        "request_method": "GET",
        "headers": {
          "Host": "localhost:3000",
          "Connection": "keep-alive",
          "Sec-Ch-Ua": "\"Not/A)Brand\";v=\"8\", \"Chromium\";v=\"126\", \"Google Chrome\";v=\"126\"",
          "Origin": "http://localhost:3000",
          "Sec-Ch-Ua-Mobile": "?0",
          "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
          "Sec-Ch-Ua-Platform": "\"macOS\"",
          "Accept": "*/*",
          "Sec-Fetch-Site": "same-origin",
          "Sec-Fetch-Mode": "cors",
          "Sec-Fetch-Dest": "script",
          "Referer": "http://localhost:3000/node_modules/.vite/deps/react-syntax-highlighter.js?v=69cd69d1",
          "Accept-Encoding": "gzip, deflate, br, zstd",
          "Accept-Language": "en-US,en;q=0.9",
          "Cookie": "__stripe_mid=ebfd26b6-c829-4742-8893-abaf894eb93edc4c96; colorMode=%22dark%22"
        },
        "protocol": "HTTP/1.1"
      },
      "id": 1,
      "thread_id": 0,
      "message": [
        {
          "name": "v",
          "value": "'b39bb78e'",
          "class": "String"
        }
      ]
    },
    {
      "event": "return",
      "http_server_response": {
        "status_code": 200,
        "headers": {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "text/javascript",
          "Cache-Control": "max-age=31536000,immutable",
          "Etag": "W/\"233f-2ooRSFlbCmao3PCNKGz0/m2/okw\""
        },
        "return_value": {
          "class": "[ResponseBody]",
          "value": "import {\n  __commonJS\n} from \"/node_modules/.vite/deps/chunk-4B2QHNJT.js?v=b39bb78e\";\n\n// node_modules/react-syntax-highlighter/node_modules/highlight.js/lib/languages/latex.js\nvar require_latex = __commonJS({\n  \"node_modules/react-syntax-highlighter/node_modules/highlight.js/lib/languages/latex.js\"(exports, module) {\n    function source(re) {\n      if (!re) return null;\n      if (typeof re === \"string\") return re;\n      return re.source;\n    }\n    function either(...args) {\n      const joined = \"(\" + args.map((x) => source(x)).join(\"|\") + \")\";\n      return joined;\n    }\n    function latex(hljs) {\n      const KNOWN_CONTROL_WORDS = either(...[\n        \"(?:NeedsTeXFormat|RequirePackage|GetIdInfo)\",\n        \"Provides(?:Expl)?(?:Package|Class|File)\",\n        \"(?:DeclareOption|ProcessOptions)\",\n        \"(?:documentclass|usepackage|input|include)\",\n        \"makeat(?:letter|other)\",\n        \"ExplSyntax(?:On|Off)\",\n        \"(?:new|renew|provide)?command\",\n        \"(?:re)newenvironment\",\n        \"(?:New|Renew|Provide|Declare)(?:Expandable)?DocumentCommand\",\n        \"(?:New|Renew|Provide|Declare)DocumentEnvironment\",\n        \"(?:(?:e|g|x)?def|let)\",\n        \"(?:begin|end)\",\n        \"(?:part|chapter|(?:sub){0,2}section|(?:sub)?paragraph)\",\n        \"caption\",\n        \"(?:label|(?:eq|page|name)?ref|(?:paren|foot|super)?cite)\",\n        \"(?:alpha|beta|[Gg]amma|[Dd]elta|(?:var)?epsilon|zeta|eta|[Tt]heta|vartheta)\",\n        \"(?:iota|(?:var)?kappa|[Ll]ambda|mu|nu|[Xx]i|[Pp]i|varpi|(?:var)rho)\",\n        \"(?:[Ss]igma|varsigma|tau|[Uu]psilon|[Pp]hi|varphi|chi|[Pp]si|[Oo]mega)\",\n        \"(?:frac|sum|prod|lim|infty|times|sqrt|leq|geq|left|right|middle|[bB]igg?)\",\n        \"(?:[lr]angle|q?quad|[lcvdi]?dots|d?dot|hat|tilde|bar)\"\n      ].map((word) => word + \"(?![a-zA-Z@:_])\"));\n      const L3_REGEX = new RegExp([\n        // A function \\module_function_name:signature or \\__module_function_name:signature,\n        // where both module and function_name need at least two characters and\n        // function_name may contain single underscores.\n        \"(?:__)?[a-zA-Z]{2,}_[a-zA-Z](?:_?[a-zA-Z])+:[a-zA-Z]*\",\n        // A variable \\scope_module_and_name_type or \\scope__module_ane_name_type,\n        // where scope is one of l, g or c, type needs at least two characters\n        // and module_and_name may contain single underscores.\n        \"[lgc]__?[a-zA-Z](?:_?[a-zA-Z])*_[a-zA-Z]{2,}\",\n        // A quark \\q_the_name or \\q__the_name or\n        // scan mark \\s_the_name or \\s__vthe_name,\n        // where variable_name needs at least two characters and\n        // may contain single underscores.\n        \"[qs]__?[a-zA-Z](?:_?[a-zA-Z])+\",\n        // Other LaTeX3 macro names that are not covered by the three rules above.\n        \"use(?:_i)?:[a-zA-Z]*\",\n        \"(?:else|fi|or):\",\n        \"(?:if|cs|exp):w\",\n        \"(?:hbox|vbox):n\",\n        \"::[a-zA-Z]_unbraced\",\n        \"::[a-zA-Z:]\"\n      ].map((pattern) => pattern + \"(?![a-zA-Z:_])\").join(\"|\"));\n      const L2_VARIANTS = [\n        { begin: /[a-zA-Z@]+/ },\n        // control word\n        { begin: /[^a-zA-Z@]?/ }\n        // control symbol\n      ];\n      const DOUBLE_CARET_VARIANTS = [\n        { begin: /\\^{6}[0-9a-f]{6}/ },\n        { begin: /\\^{5}[0-9a-f]{5}/ },\n        { begin: /\\^{4}[0-9a-f]{4}/ },\n        { begin: /\\^{3}[0-9a-f]{3}/ },\n        { begin: /\\^{2}[0-9a-f]{2}/ },\n        { begin: /\\^{2}[\\u0000-\\u007f]/ }\n      ];\n      const CONTROL_SEQUENCE = {\n        className: \"keyword\",\n        begin: /\\\\/,\n        relevance: 0,\n        contains: [\n          {\n            endsParent: true,\n            begin: KNOWN_CONTROL_WORDS\n          },\n          {\n            endsParent: true,\n            begin: L3_REGEX\n          },\n          {\n            endsParent: true,\n            variants: DOUBLE_CARET_VARIANTS\n          },\n          {\n            endsParent: true,\n            relevance: 0,\n            variants: L2_VARIANTS\n          }\n        ]\n      };\n      const MACRO_PARAM = {\n        className: \"params\",\n        relevance: 0,\n        begin: /#+\\d?/\n      };\n      const DOUBLE_CARET_CHAR = {\n        // relevance: 1\n        variants: DOUBLE_CARET_VARIANTS\n      };\n      const SPECIAL_CATCODE = {\n        className: \"built_in\",\n        relevance: 0,\n        begin: /[$&^_]/\n      };\n      const MAGIC_COMMENT = {\n        className: \"meta\",\n        begin: \"% !TeX\",\n        end: \"$\",\n        relevance: 10\n      };\n      const COMMENT = hljs.COMMENT(\n        \"%\",\n        \"$\",\n        {\n          relevance: 0\n        }\n      );\n      const EVERYTHING_BUT_VERBATIM = [\n        CONTROL_SEQUENCE,\n        MACRO_PARAM,\n        DOUBLE_CARET_CHAR,\n        SPECIAL_CATCODE,\n        MAGIC_COMMENT,\n        COMMENT\n      ];\n      const BRACE_GROUP_NO_VERBATIM = {\n        begin: /\\{/,\n        end: /\\}/,\n        relevance: 0,\n        contains: [\"self\", ...EVERYTHING_BUT_VERBATIM]\n      };\n      const ARGUMENT_BRACES = hljs.inherit(\n        BRACE_GROUP_NO_VERBATIM,\n        {\n          relevance: 0,\n          endsParent: true,\n          contains: [BRACE_GROUP_NO_VERBATIM, ...EVERYTHING_BUT_VERBATIM]\n        }\n      );\n      const ARGUMENT_BRACKETS = {\n        begin: /\\[/,\n        end: /\\]/,\n        endsParent: true,\n        relevance: 0,\n        contains: [BRACE_GROUP_NO_VERBATIM, ...EVERYTHING_BUT_VERBATIM]\n      };\n      const SPACE_GOBBLER = {\n        begin: /\\s+/,\n        relevance: 0\n      };\n      const ARGUMENT_M = [ARGUMENT_BRACES];\n      const ARGUMENT_O = [ARGUMENT_BRACKETS];\n      const ARGUMENT_AND_THEN = function(arg, starts_mode) {\n        return {\n          contains: [SPACE_GOBBLER],\n          starts: {\n            relevance: 0,\n            contains: arg,\n            starts: starts_mode\n          }\n        };\n      };\n      const CSNAME = function(csname, starts_mode) {\n        return {\n          begin: \"\\\\\\\\\" + csname + \"(?![a-zA-Z@:_])\",\n          keywords: { $pattern: /\\\\[a-zA-Z]+/, keyword: \"\\\\\" + csname },\n          relevance: 0,\n          contains: [SPACE_GOBBLER],\n          starts: starts_mode\n        };\n      };\n      const BEGIN_ENV = function(envname, starts_mode) {\n        return hljs.inherit(\n          {\n            begin: \"\\\\\\\\begin(?=[ \t]*(\\\\r?\\\\n[ \t]*)?\\\\{\" + envname + \"\\\\})\",\n            keywords: { $pattern: /\\\\[a-zA-Z]+/, keyword: \"\\\\begin\" },\n            relevance: 0\n          },\n          ARGUMENT_AND_THEN(ARGUMENT_M, starts_mode)\n        );\n      };\n      const VERBATIM_DELIMITED_EQUAL = (innerName = \"string\") => {\n        return hljs.END_SAME_AS_BEGIN({\n          className: innerName,\n          begin: /(.|\\r?\\n)/,\n          end: /(.|\\r?\\n)/,\n          excludeBegin: true,\n          excludeEnd: true,\n          endsParent: true\n        });\n      };\n      const VERBATIM_DELIMITED_ENV = function(envname) {\n        return {\n          className: \"string\",\n          end: \"(?=\\\\\\\\end\\\\{\" + envname + \"\\\\})\"\n        };\n      };\n      const VERBATIM_DELIMITED_BRACES = (innerName = \"string\") => {\n        return {\n          relevance: 0,\n          begin: /\\{/,\n          starts: {\n            endsParent: true,\n            contains: [\n              {\n                className: innerName,\n                end: /(?=\\})/,\n                endsParent: true,\n                contains: [\n                  {\n                    begin: /\\{/,\n                    end: /\\}/,\n                    relevance: 0,\n                    contains: [\"self\"]\n                  }\n                ]\n              }\n            ]\n          }\n        };\n      };\n      const VERBATIM = [\n        ...[\"verb\", \"lstinline\"].map((csname) => CSNAME(csname, { contains: [VERBATIM_DELIMITED_EQUAL()] })),\n        CSNAME(\"mint\", ARGUMENT_AND_THEN(ARGUMENT_M, { contains: [VERBATIM_DELIMITED_EQUAL()] })),\n        CSNAME(\"mintinline\", ARGUMENT_AND_THEN(ARGUMENT_M, { contains: [VERBATIM_DELIMITED_BRACES(), VERBATIM_DELIMITED_EQUAL()] })),\n        CSNAME(\"url\", { contains: [VERBATIM_DELIMITED_BRACES(\"link\"), VERBATIM_DELIMITED_BRACES(\"link\")] }),\n        CSNAME(\"hyperref\", { contains: [VERBATIM_DELIMITED_BRACES(\"link\")] }),\n        CSNAME(\"href\", ARGUMENT_AND_THEN(ARGUMENT_O, { contains: [VERBATIM_DELIMITED_BRACES(\"link\")] })),\n        ...[].concat(...[\"\", \"\\\\*\"].map((suffix) => [\n          BEGIN_ENV(\"verbatim\" + suffix, VERBATIM_DELIMITED_ENV(\"verbatim\" + suffix)),\n          BEGIN_ENV(\"filecontents\" + suffix, ARGUMENT_AND_THEN(ARGUMENT_M, VERBATIM_DELIMITED_ENV(\"filecontents\" + suffix))),\n          ...[\"\", \"B\", \"L\"].map(\n            (prefix) => BEGIN_ENV(prefix + \"Verbatim\" + suffix, ARGUMENT_AND_THEN(ARGUMENT_O, VERBATIM_DELIMITED_ENV(prefix + \"Verbatim\" + suffix)))\n          )\n        ])),\n        BEGIN_ENV(\"minted\", ARGUMENT_AND_THEN(ARGUMENT_O, ARGUMENT_AND_THEN(ARGUMENT_M, VERBATIM_DELIMITED_ENV(\"minted\"))))\n      ];\n      return {\n        name: \"LaTeX\",\n        aliases: [\"tex\"],\n        contains: [\n          ...VERBATIM,\n          ...EVERYTHING_BUT_VERBATIM\n        ]\n      };\n    }\n    module.exports = latex;\n  }\n});\n\nexport {\n  require_latex\n};\n//# sourceMappingURL=chunk-GAIKPUZG.js.map\n"
        }
      },
      "id": 2,
      "thread_id": 0,
      "parent_id": 1,
      "elapsed": 0.00031979207415133715
    }
  ],
  "version": "1.12",
  "metadata": {
    "client": {
      "name": "appmap-node",
      "version": "2.23.1",
      "url": "https://github.com/getappmap/appmap-node"
    },
    "language": {
      "name": "javascript",
      "engine": "Node.js",
      "version": "v20.15.1"
    },
    "app": "MyApp",
    "recorder": {
      "type": "requests",
      "name": "requests"
    },
    "name": "GET /node_modules/.vite/deps/chunk-GAIKPUZG.js (200) — 2024-07-28T11:41:39.387Z"
  },
  "classMap": [
    {
      "type": "http",
      "name": "HTTP server requests",
      "children": [
        {
          "type": "route",
          "name": "GET /node_modules/.vite/deps/chunk-GAIKPUZG.js"
        }
      ]
    }
  ]
}