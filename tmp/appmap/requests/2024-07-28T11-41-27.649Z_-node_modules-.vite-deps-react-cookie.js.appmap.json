{
  "events": [
    {
      "event": "call",
      "http_server_request": {
        "path_info": "/node_modules/.vite/deps/react-cookie.js",
        "request_method": "GET",
        "headers": {
          "Host": "localhost:3000",
          "Connection": "keep-alive",
          "Sec-Ch-Ua": "\"Not/A)Brand\";v=\"8\", \"Chromium\";v=\"126\", \"Google Chrome\";v=\"126\"",
          "Origin": "http://localhost:3000",
          "Sec-Ch-Ua-Mobile": "?0",
          "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
          "Sec-Ch-Ua-Platform": "\"macOS\"",
          "Accept": "*/*",
          "Sec-Fetch-Site": "same-origin",
          "Sec-Fetch-Mode": "cors",
          "Sec-Fetch-Dest": "script",
          "Referer": "http://localhost:3000/src/hooks/useManageCookies.jsx",
          "Accept-Encoding": "gzip, deflate, br, zstd",
          "Accept-Language": "en-US,en;q=0.9",
          "Cookie": "__stripe_mid=ebfd26b6-c829-4742-8893-abaf894eb93edc4c96; colorMode=%22dark%22"
        },
        "protocol": "HTTP/1.1"
      },
      "id": 1,
      "thread_id": 0,
      "message": [
        {
          "name": "v",
          "value": "'1e55bfd7'",
          "class": "String"
        }
      ]
    },
    {
      "event": "return",
      "http_server_response": {
        "status_code": 200,
        "headers": {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "text/javascript",
          "Cache-Control": "max-age=31536000,immutable",
          "Etag": "W/\"5cc7-5GpHjTYymvKVZUpvhvydf5oWJ4E\""
        },
        "return_value": {
          "class": "[ResponseBody]",
          "value": "import {\n  require_react\n} from \"/node_modules/.vite/deps/chunk-ZMLY2J2T.js?v=b39bb78e\";\nimport {\n  __toESM\n} from \"/node_modules/.vite/deps/chunk-4B2QHNJT.js?v=b39bb78e\";\n\n// node_modules/universal-cookie/esm/index.mjs\nvar parse_1 = parse;\nvar serialize_1 = serialize;\nvar __toString = Object.prototype.toString;\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\nfunction parse(str, options) {\n  if (typeof str !== \"string\") {\n    throw new TypeError(\"argument str must be a string\");\n  }\n  var obj = {};\n  var opt = options || {};\n  var dec = opt.decode || decode;\n  var index = 0;\n  while (index < str.length) {\n    var eqIdx = str.indexOf(\"=\", index);\n    if (eqIdx === -1) {\n      break;\n    }\n    var endIdx = str.indexOf(\";\", index);\n    if (endIdx === -1) {\n      endIdx = str.length;\n    } else if (endIdx < eqIdx) {\n      index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n      continue;\n    }\n    var key = str.slice(index, eqIdx).trim();\n    if (void 0 === obj[key]) {\n      var val = str.slice(eqIdx + 1, endIdx).trim();\n      if (val.charCodeAt(0) === 34) {\n        val = val.slice(1, -1);\n      }\n      obj[key] = tryDecode(val, dec);\n    }\n    index = endIdx + 1;\n  }\n  return obj;\n}\nfunction serialize(name, val, options) {\n  var opt = options || {};\n  var enc = opt.encode || encode;\n  if (typeof enc !== \"function\") {\n    throw new TypeError(\"option encode is invalid\");\n  }\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError(\"argument name is invalid\");\n  }\n  var value = enc(val);\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError(\"argument val is invalid\");\n  }\n  var str = name + \"=\" + value;\n  if (null != opt.maxAge) {\n    var maxAge = opt.maxAge - 0;\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError(\"option maxAge is invalid\");\n    }\n    str += \"; Max-Age=\" + Math.floor(maxAge);\n  }\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError(\"option domain is invalid\");\n    }\n    str += \"; Domain=\" + opt.domain;\n  }\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError(\"option path is invalid\");\n    }\n    str += \"; Path=\" + opt.path;\n  }\n  if (opt.expires) {\n    var expires = opt.expires;\n    if (!isDate(expires) || isNaN(expires.valueOf())) {\n      throw new TypeError(\"option expires is invalid\");\n    }\n    str += \"; Expires=\" + expires.toUTCString();\n  }\n  if (opt.httpOnly) {\n    str += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    str += \"; Secure\";\n  }\n  if (opt.partitioned) {\n    str += \"; Partitioned\";\n  }\n  if (opt.priority) {\n    var priority = typeof opt.priority === \"string\" ? opt.priority.toLowerCase() : opt.priority;\n    switch (priority) {\n      case \"low\":\n        str += \"; Priority=Low\";\n        break;\n      case \"medium\":\n        str += \"; Priority=Medium\";\n        break;\n      case \"high\":\n        str += \"; Priority=High\";\n        break;\n      default:\n        throw new TypeError(\"option priority is invalid\");\n    }\n  }\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === \"string\" ? opt.sameSite.toLowerCase() : opt.sameSite;\n    switch (sameSite) {\n      case true:\n        str += \"; SameSite=Strict\";\n        break;\n      case \"lax\":\n        str += \"; SameSite=Lax\";\n        break;\n      case \"strict\":\n        str += \"; SameSite=Strict\";\n        break;\n      case \"none\":\n        str += \"; SameSite=None\";\n        break;\n      default:\n        throw new TypeError(\"option sameSite is invalid\");\n    }\n  }\n  return str;\n}\nfunction decode(str) {\n  return str.indexOf(\"%\") !== -1 ? decodeURIComponent(str) : str;\n}\nfunction encode(val) {\n  return encodeURIComponent(val);\n}\nfunction isDate(val) {\n  return __toString.call(val) === \"[object Date]\" || val instanceof Date;\n}\nfunction tryDecode(str, decode2) {\n  try {\n    return decode2(str);\n  } catch (e) {\n    return str;\n  }\n}\nfunction hasDocumentCookie() {\n  const testingValue = typeof global === \"undefined\" ? void 0 : global.TEST_HAS_DOCUMENT_COOKIE;\n  if (typeof testingValue === \"boolean\") {\n    return testingValue;\n  }\n  return typeof document === \"object\" && typeof document.cookie === \"string\";\n}\nfunction parseCookies(cookies) {\n  if (typeof cookies === \"string\") {\n    return parse_1(cookies);\n  } else if (typeof cookies === \"object\" && cookies !== null) {\n    return cookies;\n  } else {\n    return {};\n  }\n}\nfunction readCookie(value, options = {}) {\n  const cleanValue = cleanupCookieValue(value);\n  if (!options.doNotParse) {\n    try {\n      return JSON.parse(cleanValue);\n    } catch (e) {\n    }\n  }\n  return value;\n}\nfunction cleanupCookieValue(value) {\n  if (value && value[0] === \"j\" && value[1] === \":\") {\n    return value.substr(2);\n  }\n  return value;\n}\nvar Cookies = class {\n  constructor(cookies, defaultSetOptions = {}) {\n    this.changeListeners = [];\n    this.HAS_DOCUMENT_COOKIE = false;\n    this.update = () => {\n      if (!this.HAS_DOCUMENT_COOKIE) {\n        return;\n      }\n      const previousCookies = this.cookies;\n      this.cookies = parse_1(document.cookie);\n      this._checkChanges(previousCookies);\n    };\n    const domCookies = typeof document === \"undefined\" ? \"\" : document.cookie;\n    this.cookies = parseCookies(cookies || domCookies);\n    this.defaultSetOptions = defaultSetOptions;\n    this.HAS_DOCUMENT_COOKIE = hasDocumentCookie();\n  }\n  _emitChange(params) {\n    for (let i = 0; i < this.changeListeners.length; ++i) {\n      this.changeListeners[i](params);\n    }\n  }\n  _checkChanges(previousCookies) {\n    const names = new Set(Object.keys(previousCookies).concat(Object.keys(this.cookies)));\n    names.forEach((name) => {\n      if (previousCookies[name] !== this.cookies[name]) {\n        this._emitChange({\n          name,\n          value: readCookie(this.cookies[name])\n        });\n      }\n    });\n  }\n  _startPolling() {\n    this.pollingInterval = setInterval(this.update, 300);\n  }\n  _stopPolling() {\n    if (this.pollingInterval) {\n      clearInterval(this.pollingInterval);\n    }\n  }\n  get(name, options = {}) {\n    if (!options.doNotUpdate) {\n      this.update();\n    }\n    return readCookie(this.cookies[name], options);\n  }\n  getAll(options = {}) {\n    if (!options.doNotUpdate) {\n      this.update();\n    }\n    const result = {};\n    for (let name in this.cookies) {\n      result[name] = readCookie(this.cookies[name], options);\n    }\n    return result;\n  }\n  set(name, value, options) {\n    if (options) {\n      options = Object.assign(Object.assign({}, this.defaultSetOptions), options);\n    } else {\n      options = this.defaultSetOptions;\n    }\n    const stringValue = typeof value === \"string\" ? value : JSON.stringify(value);\n    this.cookies = Object.assign(Object.assign({}, this.cookies), { [name]: stringValue });\n    if (this.HAS_DOCUMENT_COOKIE) {\n      document.cookie = serialize_1(name, stringValue, options);\n    }\n    this._emitChange({ name, value, options });\n  }\n  remove(name, options) {\n    const finalOptions = options = Object.assign(Object.assign(Object.assign({}, this.defaultSetOptions), options), { expires: new Date(1970, 1, 1, 0, 0, 1), maxAge: 0 });\n    this.cookies = Object.assign({}, this.cookies);\n    delete this.cookies[name];\n    if (this.HAS_DOCUMENT_COOKIE) {\n      document.cookie = serialize_1(name, \"\", finalOptions);\n    }\n    this._emitChange({ name, value: void 0, options });\n  }\n  addChangeListener(callback) {\n    this.changeListeners.push(callback);\n    if (this.HAS_DOCUMENT_COOKIE && this.changeListeners.length === 1) {\n      if (typeof window === \"object\" && \"cookieStore\" in window) {\n        window.cookieStore.addEventListener(\"change\", this.update);\n      } else {\n        this._startPolling();\n      }\n    }\n  }\n  removeChangeListener(callback) {\n    const idx = this.changeListeners.indexOf(callback);\n    if (idx >= 0) {\n      this.changeListeners.splice(idx, 1);\n    }\n    if (this.HAS_DOCUMENT_COOKIE && this.changeListeners.length === 0) {\n      if (typeof window === \"object\" && \"cookieStore\" in window) {\n        window.cookieStore.removeEventListener(\"change\", this.update);\n      } else {\n        this._stopPolling();\n      }\n    }\n  }\n};\n\n// node_modules/react-cookie/esm/index.mjs\nvar React = __toESM(require_react(), 1);\nvar import_react = __toESM(require_react(), 1);\nvar CookiesContext = React.createContext(new Cookies());\nvar { Provider, Consumer } = CookiesContext;\nvar CookiesProvider = class extends React.Component {\n  constructor(props) {\n    super(props);\n    if (props.cookies) {\n      this.cookies = props.cookies;\n    } else {\n      this.cookies = new Cookies(void 0, props.defaultSetOptions);\n    }\n  }\n  render() {\n    return React.createElement(Provider, { value: this.cookies }, this.props.children);\n  }\n};\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n    t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n        t[p[i]] = s[p[i]];\n    }\n  return t;\n}\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar reactIs$1 = { exports: {} };\nvar reactIs_development = {};\nvar hasRequiredReactIs_development;\nfunction requireReactIs_development() {\n  if (hasRequiredReactIs_development) return reactIs_development;\n  hasRequiredReactIs_development = 1;\n  if (true) {\n    (function() {\n      var hasSymbol = typeof Symbol === \"function\" && Symbol.for;\n      var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for(\"react.element\") : 60103;\n      var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for(\"react.portal\") : 60106;\n      var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for(\"react.fragment\") : 60107;\n      var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for(\"react.strict_mode\") : 60108;\n      var REACT_PROFILER_TYPE = hasSymbo... (13751 more characters)"
        }
      },
      "id": 2,
      "thread_id": 0,
      "parent_id": 1,
      "elapsed": 0.0004792920080944896
    }
  ],
  "version": "1.12",
  "metadata": {
    "client": {
      "name": "appmap-node",
      "version": "2.23.1",
      "url": "https://github.com/getappmap/appmap-node"
    },
    "language": {
      "name": "javascript",
      "engine": "Node.js",
      "version": "v20.15.1"
    },
    "app": "MyApp",
    "recorder": {
      "type": "requests",
      "name": "requests"
    },
    "name": "GET /node_modules/.vite/deps/react-cookie.js (200) — 2024-07-28T11:41:27.649Z"
  },
  "classMap": [
    {
      "type": "http",
      "name": "HTTP server requests",
      "children": [
        {
          "type": "route",
          "name": "GET /node_modules/.vite/deps/react-cookie.js"
        }
      ]
    }
  ]
}