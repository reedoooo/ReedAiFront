{
  "events": [
    {
      "event": "call",
      "http_server_request": {
        "path_info": "/node_modules/.vite/deps/chunk-RIPPH7IM.js",
        "request_method": "GET",
        "headers": {
          "Host": "localhost:3000",
          "Connection": "keep-alive",
          "Sec-Ch-Ua": "\"Not/A)Brand\";v=\"8\", \"Chromium\";v=\"126\", \"Google Chrome\";v=\"126\"",
          "Origin": "http://localhost:3000",
          "Sec-Ch-Ua-Mobile": "?0",
          "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
          "Sec-Ch-Ua-Platform": "\"macOS\"",
          "Accept": "*/*",
          "Sec-Fetch-Site": "same-origin",
          "Sec-Fetch-Mode": "cors",
          "Sec-Fetch-Dest": "script",
          "Referer": "http://localhost:3000/node_modules/.vite/deps/react-syntax-highlighter.js?v=69cd69d1",
          "Accept-Encoding": "gzip, deflate, br, zstd",
          "Accept-Language": "en-US,en;q=0.9",
          "Cookie": "__stripe_mid=ebfd26b6-c829-4742-8893-abaf894eb93edc4c96; colorMode=%22dark%22"
        },
        "protocol": "HTTP/1.1"
      },
      "id": 1,
      "thread_id": 0,
      "message": [
        {
          "name": "v",
          "value": "'b39bb78e'",
          "class": "String"
        }
      ]
    },
    {
      "event": "return",
      "http_server_response": {
        "status_code": 200,
        "headers": {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "text/javascript",
          "Cache-Control": "max-age=31536000,immutable",
          "Etag": "W/\"226e-VzeXWGqswSj0ot4k0/TOXCzbzCw\""
        },
        "return_value": {
          "class": "[ResponseBody]",
          "value": "import {\n  __commonJS\n} from \"/node_modules/.vite/deps/chunk-4B2QHNJT.js?v=b39bb78e\";\n\n// node_modules/refractor/lang/js-templates.js\nvar require_js_templates = __commonJS({\n  \"node_modules/refractor/lang/js-templates.js\"(exports, module) {\n    module.exports = jsTemplates;\n    jsTemplates.displayName = \"jsTemplates\";\n    jsTemplates.aliases = [];\n    function jsTemplates(Prism) {\n      ;\n      (function(Prism2) {\n        var templateString = Prism2.languages.javascript[\"template-string\"];\n        var templateLiteralPattern = templateString.pattern.source;\n        var interpolationObject = templateString.inside[\"interpolation\"];\n        var interpolationPunctuationObject = interpolationObject.inside[\"interpolation-punctuation\"];\n        var interpolationPattern = interpolationObject.pattern.source;\n        function createTemplate(language, tag) {\n          if (!Prism2.languages[language]) {\n            return void 0;\n          }\n          return {\n            pattern: RegExp(\"((?:\" + tag + \")\\\\s*)\" + templateLiteralPattern),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n              \"template-punctuation\": {\n                pattern: /^`|`$/,\n                alias: \"string\"\n              },\n              \"embedded-code\": {\n                pattern: /[\\s\\S]+/,\n                alias: language\n              }\n            }\n          };\n        }\n        Prism2.languages.javascript[\"template-string\"] = [\n          // styled-jsx:\n          //   css`a { color: #25F; }`\n          // styled-components:\n          //   styled.h1`color: red;`\n          createTemplate(\n            \"css\",\n            /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source\n          ),\n          // html`<p></p>`\n          // div.innerHTML = `<p></p>`\n          createTemplate(\"html\", /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source),\n          // svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`\n          createTemplate(\"svg\", /\\bsvg/.source),\n          // md`# h1`, markdown`## h2`\n          createTemplate(\"markdown\", /\\b(?:markdown|md)/.source),\n          // gql`...`, graphql`...`, graphql.experimental`...`\n          createTemplate(\n            \"graphql\",\n            /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source\n          ),\n          // sql`...`\n          createTemplate(\"sql\", /\\bsql/.source),\n          // vanilla template string\n          templateString\n        ].filter(Boolean);\n        function getPlaceholder(counter, language) {\n          return \"___\" + language.toUpperCase() + \"_\" + counter + \"___\";\n        }\n        function tokenizeWithHooks(code, grammar, language) {\n          var env = {\n            code,\n            grammar,\n            language\n          };\n          Prism2.hooks.run(\"before-tokenize\", env);\n          env.tokens = Prism2.tokenize(env.code, env.grammar);\n          Prism2.hooks.run(\"after-tokenize\", env);\n          return env.tokens;\n        }\n        function tokenizeInterpolationExpression(expression) {\n          var tempGrammar = {};\n          tempGrammar[\"interpolation-punctuation\"] = interpolationPunctuationObject;\n          var tokens = Prism2.tokenize(expression, tempGrammar);\n          if (tokens.length === 3) {\n            var args = [1, 1];\n            args.push.apply(\n              args,\n              tokenizeWithHooks(tokens[1], Prism2.languages.javascript, \"javascript\")\n            );\n            tokens.splice.apply(tokens, args);\n          }\n          return new Prism2.Token(\n            \"interpolation\",\n            tokens,\n            interpolationObject.alias,\n            expression\n          );\n        }\n        function tokenizeEmbedded(code, grammar, language) {\n          var _tokens = Prism2.tokenize(code, {\n            interpolation: {\n              pattern: RegExp(interpolationPattern),\n              lookbehind: true\n            }\n          });\n          var placeholderCounter = 0;\n          var placeholderMap = {};\n          var embeddedCode = _tokens.map(function(token) {\n            if (typeof token === \"string\") {\n              return token;\n            } else {\n              var interpolationExpression = token.content;\n              var placeholder;\n              while (code.indexOf(\n                placeholder = getPlaceholder(placeholderCounter++, language)\n              ) !== -1) {\n              }\n              placeholderMap[placeholder] = interpolationExpression;\n              return placeholder;\n            }\n          }).join(\"\");\n          var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language);\n          var placeholders = Object.keys(placeholderMap);\n          placeholderCounter = 0;\n          function walkTokens(tokens) {\n            for (var i = 0; i < tokens.length; i++) {\n              if (placeholderCounter >= placeholders.length) {\n                return;\n              }\n              var token = tokens[i];\n              if (typeof token === \"string\" || typeof token.content === \"string\") {\n                var placeholder = placeholders[placeholderCounter];\n                var s = typeof token === \"string\" ? token : (\n                  /** @type {string} */\n                  token.content\n                );\n                var index = s.indexOf(placeholder);\n                if (index !== -1) {\n                  ++placeholderCounter;\n                  var before = s.substring(0, index);\n                  var middle = tokenizeInterpolationExpression(\n                    placeholderMap[placeholder]\n                  );\n                  var after = s.substring(index + placeholder.length);\n                  var replacement = [];\n                  if (before) {\n                    replacement.push(before);\n                  }\n                  replacement.push(middle);\n                  if (after) {\n                    var afterTokens = [after];\n                    walkTokens(afterTokens);\n                    replacement.push.apply(replacement, afterTokens);\n                  }\n                  if (typeof token === \"string\") {\n                    tokens.splice.apply(tokens, [i, 1].concat(replacement));\n                    i += replacement.length - 1;\n                  } else {\n                    token.content = replacement;\n                  }\n                }\n              } else {\n                var content = token.content;\n                if (Array.isArray(content)) {\n                  walkTokens(content);\n                } else {\n                  walkTokens([content]);\n                }\n              }\n            }\n          }\n          walkTokens(embeddedTokens);\n          return new Prism2.Token(\n            language,\n            embeddedTokens,\n            \"language-\" + language,\n            code\n          );\n        }\n        var supportedLanguages = {\n          javascript: true,\n          js: true,\n          typescript: true,\n          ts: true,\n          jsx: true,\n          tsx: true\n        };\n        Prism2.hooks.add(\"after-tokenize\", function(env) {\n          if (!(env.language in supportedLanguages)) {\n            return;\n          }\n          function findTemplateStrings(tokens) {\n            for (var i = 0, l = tokens.length; i < l; i++) {\n              var token = tokens[i];\n              if (typeof token === \"string\") {\n                continue;\n              }\n              var content = token.content;\n              if (!Array.isArray(content)) {\n                if (typeof content !== \"string\") {\n                  findTemplateStrings([content]);\n                }\n                continue;\n              }\n              if (token.type === \"template-string\") {\n                var embedded = content[1];\n                if (content.length === 3 && typeof embedded !== \"string\" && embedded.type === \"embedded-code\") {\n                  var code = stringContent(embedded);\n                  var alias = embedded.alias;\n                  var language = Array.isArray(alias) ? alias[0] : alias;\n                  var grammar = Prism2.languages[language];\n                  if (!grammar) {\n                    continue;\n                  }\n                  content[1] = tokenizeEmbedded(code, grammar, language);\n                }\n              } else {\n                findTemplateStrings(content);\n              }\n            }\n          }\n          findTemplateStrings(env.tokens);\n        });\n        function stringContent(value) {\n          if (typeof value === \"string\") {\n            return value;\n          } else if (Array.isArray(value)) {\n            return value.map(stringContent).join(\"\");\n          } else {\n            return stringContent(value.content);\n          }\n        }\n      })(Prism);\n    }\n  }\n});\n\nexport {\n  require_js_templates\n};\n//# sourceMappingURL=chunk-RIPPH7IM.js.map\n"
        }
      },
      "id": 2,
      "thread_id": 0,
      "parent_id": 1,
      "elapsed": 0.00042558310087770224
    }
  ],
  "version": "1.12",
  "metadata": {
    "client": {
      "name": "appmap-node",
      "version": "2.23.1",
      "url": "https://github.com/getappmap/appmap-node"
    },
    "language": {
      "name": "javascript",
      "engine": "Node.js",
      "version": "v20.15.1"
    },
    "app": "MyApp",
    "recorder": {
      "type": "requests",
      "name": "requests"
    },
    "name": "GET /node_modules/.vite/deps/chunk-RIPPH7IM.js (200) â€” 2024-07-28T11:41:34.653Z"
  },
  "classMap": [
    {
      "type": "http",
      "name": "HTTP server requests",
      "children": [
        {
          "type": "route",
          "name": "GET /node_modules/.vite/deps/chunk-RIPPH7IM.js"
        }
      ]
    }
  ]
}